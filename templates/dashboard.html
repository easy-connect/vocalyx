<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Vocalyx - Transcriptions Dashboard</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastr@2.1.4/build/toastr.min.css">
<style>
    :root {
        --primary: #4a90e2;
        --success: #28a745;
        --warning: #ffc107;
        --danger: #dc3545;
        --light: #f8f9fa;
        --dark: #343a40;
    }
    body {
        font-family: 'Inter', sans-serif;
        margin: 0;
        background: #f0f2f5;
        color: #333;
    }
    header {
        position: sticky;
        top: 0;
        background: linear-gradient(90deg, var(--primary), #357ABD);
        padding: 0.7rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 1000;
        color: white;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    .filters {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }
    .filters select, .filters input {
        padding: 0.3rem 0.5rem;
        border-radius: 6px;
        border: none;
        background: white;
        color: #333;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s;
    }
    .filters select:hover, .filters input:hover {
        background: #e0e0e0;
    }
    .btn {
        display: flex;
        align-items: center;
        gap: 0.3rem;
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 6px;
        padding: 0.3rem 0.7rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        text-decoration: none;
    }
    .btn:hover {
        opacity: 0.9;
        transform: scale(1.02);
    }
    .btn-primary {
        background: var(--primary);
    }
    .btn-success {
        background: var(--success);
    }
    .btn-warning {
        background: var(--warning);
        color: #212529;
    }
    .btn-danger {
        background: var(--danger);
    }
    #current-time {
        font-weight: 600;
        font-size: 0.95rem;
    }
    h1 {
        text-align: center;
        margin: 1rem 0;
    }
    .cards {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center;
        padding: 1rem;
        min-height: 200px;
    }
    .card {
        background: white;
        border-radius: 14px;
        padding: 1.3rem;
        width: 320px;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08);
        transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
        position: relative;
        cursor: pointer;
        opacity: 0;
        transform: translateY(20px);
    }
    .card.visible {
        opacity: 1;
        transform: translateY(0);
    }
    .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 14px 28px rgba(0,0,0,0.15);
    }
    .status-badge {
        position: absolute;
        top: 1rem;
        right: 1rem;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: gray;
        transition: background 0.3s;
    }
    .status-badge::after {
        content: attr(data-tooltip);
        position: absolute;
        right: 120%;
        top: 50%;
        transform: translateY(-50%);
        background: var(--dark);
        color: white;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
        font-size: 0.8rem;
        opacity: 0;
        transition: opacity 0.3s;
        white-space: nowrap;
    }
    .card:hover .status-badge::after {
        opacity: 1;
    }
    .status-pending .status-badge {
        background: linear-gradient(45deg, #6c757d, #adb5bd);
    }
    .status-pending .status-badge::after {
        content: "En attente";
    }
    .status-processing .status-badge {
        background: linear-gradient(45deg, var(--warning), #ffd966);
        animation: pulse 2s infinite;
    }
    .status-processing .status-badge::after {
        content: "En cours";
    }
    .status-done .status-badge {
        background: linear-gradient(45deg, var(--success), #5cd65c);
    }
    .status-done .status-badge::after {
        content: "Termin√©";
    }
    .status-error .status-badge {
        background: linear-gradient(45deg, var(--danger), #ff6b6b);
    }
    .status-error .status-badge::after {
        content: "Erreur";
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    .card h3 {
        margin-top: 0;
        font-size: 1.1rem;
        font-weight: 600;
    }
    .card p {
        margin: 0.3rem 0;
        font-size: 0.92rem;
        line-height: 1.35;
    }
    .card-buttons {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.8rem;
    }
    .card-buttons button {
        flex: 1;
        padding: 0.4rem;
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
    }
    .modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.5);
        animation: fadeIn 0.3s;
    }
    .modal-content {
        background-color: #ffffff;
        margin: 3% auto;
        padding: 1.5rem;
        border-radius: 14px;
        width: 90%;
        max-width: 1000px;
        box-shadow: 0 12px 30px rgba(0,0,0,0.18);
        position: relative;
        max-height: 80vh;
        overflow-y: auto;
        animation: scaleIn 0.3s;
    }
    .close {
        color: #aaa;
        float: right;
        font-size: 1.5rem;
        font-weight: bold;
        position: absolute;
        right: 1rem;
        top: 0.5rem;
        cursor: pointer;
        transition: color 0.2s;
    }
    .close:hover {
        color: black;
    }
    .segment {
        border-bottom: 1px solid #ddd;
        padding: 0.5rem 0;
        cursor: pointer;
    }
    .segment:hover {
        background: #f0f0f0;
    }
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    @keyframes scaleIn {
        from { transform: scale(0.95); }
        to { transform: scale(1); }
    }
    .pagination {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin: 1rem 0;
    }
    .pagination button {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 6px;
        background: var(--light);
        cursor: pointer;
        transition: all 0.3s;
    }
    .pagination button:hover {
        background: #d0d0d0;
    }
    .pagination button.active {
        background: var(--primary);
        color: white;
    }
    button:focus, [tabindex="0"]:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
    }
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255,255,255,0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    }
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--primary);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
</head>
<body>
<div class="loading-overlay" id="loading-overlay">
    <div class="spinner"></div>
</div>
<header>
    <div class="filters">
        <label for="status-filter">Statut:</label>
        <select id="status-filter">
            <option value="">Tous</option>
            <option value="pending">En attente</option>
            <option value="processing">En cours</option>
            <option value="done">Termin√©</option>
            <option value="error">Erreur</option>
        </select>
        <input type="text" id="search-input" placeholder="Rechercher...">
    </div>
    <div style="display:flex;align-items:center;gap:1rem;">
        <div id="current-time"></div>
        <a href="/docs" class="btn btn-primary">
            <span>API Docs</span>
        </a>
    </div>
    <div style="display:flex;align-items:center;gap:0.5rem;">
        <input type="file" id="upload-input" accept="audio/*" style="display:none;">
        <button id="upload-btn" class="btn btn-warning">Upload Audio</button>
        <button id="export-btn" class="btn btn-success">Exporter</button>
    </div>
</header>
<h1>Transcriptions r√©centes</h1>
<div class="cards" id="cards-container"></div>
<div class="pagination" id="pagination"></div>
<div id="modal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <div id="modal-body"></div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/toastr@2.1.4/build/toastr.min.js"></script>
<script>
    // √âtat global
    let currentPage = 1;
    let currentLimit = 10;
    let pollingInterval = null;

    function formatHumanDate(isoString) {
        if (!isoString) return '-';
        const d = new Date(isoString);
        return d.toLocaleString('fr-FR', {
            year: 'numeric', month: 'short', day: 'numeric',
            hour: '2-digit', minute: '2-digit', second: '2-digit'
        });
    }

    function showToast(message, type="success") {
        toastr.options = {
            positionClass: "toast-top-right",
            timeOut: 3000,
            progressBar: true,
        };
        toastr[type](message);
    }

    const modal = document.getElementById("modal");
    const modalBody = document.getElementById("modal-body");
    const spanClose = document.querySelector(".close");

    function openModal() {
        modal.style.display = "block";
        document.body.style.overflow = "hidden";
        document.addEventListener("keydown", handleKeyDown);
    }

    function closeModal() {
        modal.style.display = "none";
        document.body.style.overflow = "";
        document.removeEventListener("keydown", handleKeyDown);
    }

    function handleKeyDown(e) {
        if (e.key === "Escape") closeModal();
    }

    spanClose.onclick = closeModal;
    window.onclick = (event) => {
        if (event.target == modal) closeModal();
    };

    function renderTranscriptionModal(data) {
        const segmentsHtml = (data.segments || []).map(seg => `
            <div class="segment" data-start="${seg.start}" tabindex="0">
                <strong>[${seg.start} - ${seg.end}]</strong> ${seg.text || ''}
            </div>
        `).join('');
        
        modalBody.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;">
                <h2>D√©tails de la transcription</h2>
                <button class="btn btn-primary" onclick="closeModal()">‚Üê Retour</button>
            </div>
            <div style="display:flex;gap:1rem;flex-wrap:wrap;margin-bottom:1rem;">
                <div style="flex:1;min-width:200px;background:#f9f9f9;padding:1rem;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.08);">
                    <h4>Informations</h4>
                    <div style="display:flex;flex-wrap:wrap;gap:1rem;">
                        <div style="flex:1;">
                            <p><strong>ID:</strong> ${data.id || '-'}</p>
                            <p><strong>Statut:</strong> ${data.status || '-'}</p>
                            <p><strong>Langue:</strong> ${data.language || '-'}</p>
                        </div>
                        <div style="flex:1;">
                            <p><strong>Temps de traitement:</strong> ${data.processing_time ?? '-'}s</p>
                            <p><strong>Dur√©e:</strong> ${data.duration ?? '-'}s</p>
                            <p><strong>Cr√©√©:</strong> ${formatHumanDate(data.created_at)}</p>
                            <p><strong>Termin√©:</strong> ${formatHumanDate(data.finished_at)}</p>
                        </div>
                    </div>
                </div>
            </div>
            <div style="display:flex;gap:1rem;flex-wrap:wrap;">
                <div class="segments-panel" style="width:280px;max-height:70vh;overflow-y:auto;background:white;padding:1rem;border-radius:12px;box-shadow:0 6px 12px rgba(0,0,0,0.1);">
                    <h3>Segments (${data.segments_count || 0})</h3>
                    ${segmentsHtml || '<p>Aucun segment disponible.</p>'}
                </div>
                <div class="text-panel" style="flex:1;max-height:70vh;overflow-y:auto;background:white;padding:1rem;border-radius:12px;box-shadow:0 6px 12px rgba(0,0,0,0.1);">
                    <h3>Texte complet</h3>
                    <p style="white-space:pre-wrap;">${data.text || 'Aucun texte disponible.'}</p>
                    <div style="margin-top:1rem;">
                        <a href="/transcribe/${data.id}" target="_blank" class="btn btn-primary">Voir le JSON</a>
                    </div>
                </div>
            </div>
        `;
        
        document.querySelectorAll(".segment").forEach(seg => {
            seg.addEventListener("click", () => {
                document.querySelectorAll(".segment").forEach(s => s.style.background = "");
                seg.style.background = "#e9f7fe";
            });
        });
    }

    function attachDetailEvents() {
        document.querySelectorAll(".btn-detail").forEach(btn => {
            btn.addEventListener("click", async (e) => {
                e.stopPropagation();
                const card = e.target.closest(".card");
                const id = card.dataset.id;
                openModal();
                modalBody.innerHTML = `
                    <div style="text-align:center;padding:2rem;">
                        <div class="spinner"></div>
                        <p>Chargement des d√©tails...</p>
                    </div>
                `;
                try {
                    const resp = await fetch(`/transcribe/${id}`);
                    if (!resp.ok) throw new Error(`Erreur: ${resp.status}`);
                    const data = await resp.json();
                    renderTranscriptionModal(data);
                } catch (err) {
                    modalBody.innerHTML = `
                        <div style="text-align:center;padding:2rem;color:red;">
                            <p>‚ùå Erreur: ${err.message}</p>
                            <button onclick="closeModal()" class="btn btn-danger">Fermer</button>
                        </div>
                    `;
                }
            });
        });
    }

    function attachDeleteEvents() {
        document.querySelectorAll(".btn-delete").forEach(btn => {
            btn.addEventListener("click", async (e) => {
                e.stopPropagation();
                const card = e.target.closest(".card");
                const id = card.dataset.id;
                if (!confirm(`Supprimer la transcription ${id.substring(0, 8)}... ?`)) return;
                
                try {
                    const resp = await fetch(`/transcribe/${id}`, { method: "DELETE" });
                    if (!resp.ok) throw new Error(await resp.text());
                    showToast(`Transcription supprim√©e !`, "success");
                    
                    // Animation de suppression
                    card.style.transition = "opacity 0.3s, transform 0.3s";
                    card.style.opacity = "0";
                    card.style.transform = "scale(0.8)";
                    
                    setTimeout(() => {
                        refreshCards(currentPage, currentLimit);
                    }, 300);
                } catch (err) {
                    showToast(`Erreur: ${err.message}`, "error");
                }
            });
        });
    }

    async function refreshCards(page=1, limit=10) {
        const status = document.getElementById("status-filter").value;
        const search = document.getElementById("search-input").value;
        
        currentPage = page;
        currentLimit = limit;
        
        try {
            let url = `/transcribe/recent?limit=${limit}&page=${page}`;
            if (status) url += `&status=${status}`;
            if (search) url += `&search=${encodeURIComponent(search)}`;
            
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
            const entries = await resp.json();
            
            // R√©cup√©rer le total pour la pagination
            let countUrl = `/transcribe/count?`;
            if (status) countUrl += `status=${status}&`;
            if (search) countUrl += `search=${encodeURIComponent(search)}`;
            
            const countResp = await fetch(countUrl);
            const countData = await countResp.json();
            const totalPages = Math.ceil(countData.total / limit);
            
            const container = document.getElementById("cards-container");
            container.innerHTML = "";
            
            if (entries.length === 0) {
                container.innerHTML = `<div style="text-align:center;width:100%;padding:2rem;">Aucune transcription trouv√©e.</div>`;
                updatePagination(page, 0);
                return;
            }
            
            const fragment = document.createDocumentFragment();
            entries.forEach((entry, i) => {
                const card = document.createElement("div");
                card.className = `card status-${entry.status || 'unknown'}`;
                card.dataset.id = entry.id;
                card.innerHTML = `
                    <div class="status-badge"></div>
                    <h3>ID: ${entry.id.substring(0, 8)}...</h3>
                    <p><strong>Statut:</strong> <span class="status-text">${entry.status || '-'}</span></p>
                    <p><strong>Langue:</strong> ${entry.language || 'inconnu'}</p>
                    <p><strong>Dur√©e:</strong> ${entry.duration ?? '-'}s</p>
                    <p><strong>Cr√©√©:</strong> ${formatHumanDate(entry.created_at)}</p>
                    <p><strong>Aper√ßu:</strong> ${entry.text ? entry.text.substring(0, 100) + (entry.text.length > 100 ? '...' : '') : '-'}</p>
                    <div class="card-buttons">
                        <button class="btn-detail btn btn-primary">D√©tails</button>
                        <button class="btn-delete btn btn-danger">Supprimer</button>
                    </div>
                `;
                fragment.appendChild(card);
                setTimeout(() => card.classList.add('visible'), i * 50);
            });
            
            container.appendChild(fragment);
            attachDetailEvents();
            attachDeleteEvents();
            updatePagination(page, totalPages);
            
        } catch (err) {
            console.error("Erreur:", err);
            document.getElementById("cards-container").innerHTML =
                `<div style="color:red;text-align:center;padding:2rem;">Erreur de chargement. Veuillez r√©essayer.</div>`;
        }
    }

    function updatePagination(currentPage, totalPages) {
        const pagination = document.getElementById("pagination");
        pagination.innerHTML = "";
        
        if (totalPages <= 1) return;
        
        for (let i = 1; i <= totalPages; i++) {
            const btn = document.createElement("button");
            btn.textContent = i;
            btn.dataset.page = i;
            if (i === currentPage) btn.classList.add("active");
            btn.addEventListener("click", () => {
                refreshCards(i, currentLimit);
            });
            pagination.appendChild(btn);
        }
    }

    document.getElementById("upload-btn").addEventListener("click", () => {
        document.getElementById("upload-input").click();
    });

    document.getElementById("upload-input").addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        const formData = new FormData();
        formData.append("file", file);
        
        const loadingOverlay = document.getElementById("loading-overlay");
        loadingOverlay.style.display = "flex";
        
        try {
            const resp = await fetch("/transcribe", {
                method: "POST",
                body: formData
            });
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            showToast(`‚úÖ Upload r√©ussi ! ID: ${data.transcription_id.substring(0, 8)}...`, "success");
            
            // Rafra√Æchir imm√©diatement
            await refreshCards(1, currentLimit);
            
        } catch (err) {
            showToast(`‚ùå Erreur: ${err.message}`, "error");
        } finally {
            loadingOverlay.style.display = "none";
            event.target.value = "";
        }
    });

    document.getElementById("export-btn").addEventListener("click", async () => {
        try {
            const resp = await fetch("/transcribe/export");
            if (!resp.ok) throw new Error(`Erreur: ${resp.status}`);
            const data = await resp.json();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `transcriptions_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            showToast("Export termin√© !", "success");
        } catch (err) {
            showToast(`Erreur: ${err.message}`, "error");
        }
    });

    document.getElementById("status-filter").addEventListener("change", () => {
        refreshCards(1, currentLimit);
    });

    document.getElementById("search-input").addEventListener("input", () => {
        refreshCards(1, currentLimit);
    });

    function updateCurrentTime() {
        const now = new Date();
        document.getElementById("current-time").textContent = now.toLocaleString('fr-FR', {
            year: 'numeric', month: 'short', day: 'numeric',
            hour: '2-digit', minute: '2-digit', second: '2-digit'
        });
    }
    
    setInterval(updateCurrentTime, 1000);
    updateCurrentTime();

    // Polling intelligent
    function startPolling() {
        if (pollingInterval) clearInterval(pollingInterval);
        
        pollingInterval = setInterval(async () => {
            // Ne pas rafra√Æchir si la modal est ouverte
            if (modal.style.display === "block") return;
            
            // Rafra√Æchir sans animation pour le polling
            const status = document.getElementById("status-filter").value;
            const search = document.getElementById("search-input").value;
            
            try {
                let url = `/transcribe/recent?limit=${currentLimit}&page=${currentPage}`;
                if (status) url += `&status=${status}`;
                if (search) url += `&search=${encodeURIComponent(search)}`;
                
                const resp = await fetch(url);
                if (!resp.ok) return;
                const entries = await resp.json();
                
                const container = document.getElementById("cards-container");
                const existingIds = new Set(
                    Array.from(container.querySelectorAll('.card')).map(c => c.dataset.id)
                );
                
                const newIds = new Set(entries.map(e => e.id));
                
                // V√©rifier s'il y a des changements
                const hasChanges = 
                    existingIds.size !== newIds.size || 
                    ![...existingIds].every(id => newIds.has(id));
                
                if (hasChanges) {
                    console.log('üîÑ Changements d√©tect√©s, rafra√Æchissement...');
                    await refreshCards(currentPage, currentLimit);
                } else {
                    // Mettre √† jour uniquement les statuts si n√©cessaire
                    entries.forEach(entry => {
                        const card = container.querySelector(`[data-id="${entry.id}"]`);
                        if (card) {
                            const statusText = card.querySelector('.status-text');
                            if (statusText && statusText.textContent !== entry.status) {
                                // Statut chang√©, rafra√Æchir compl√®tement
                                refreshCards(currentPage, currentLimit);
                            }
                        }
                    });
                }
            } catch (err) {
                console.error('Erreur polling:', err);
            }
        }, 5000); // Polling toutes les 5 secondes
    }

    function stopPolling() {
        if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    }

    // D√©marrer le polling au chargement
    refreshCards(1, currentLimit);
    startPolling();

    // Arr√™ter le polling quand la page est cach√©e
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            stopPolling();
        } else {
            startPolling();
        }
    });
</script>
</body>
</html>